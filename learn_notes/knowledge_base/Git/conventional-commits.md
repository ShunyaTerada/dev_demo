# Conventional Commits (コミットメッセージの命名規則)

**学習日**: 2025-11-26
**参照ドキュメント**: [Conventional Commits 1.0.0](https://www.conventionalcommits.org/ja/v1.0.0/)

## 1. 概念と前提知識（The Big Picture）
Gitのコミットメッセージは、開発者から未来の自分やチームメンバーへの「手紙」です。しかし、件名が「修正」「更新」だけでは、中身を開くまで何をしたか分かりません。

**Conventional Commits** は、コミットメッセージに**「ラベル（タグ）」**を付けるための共通ルールです。
現実世界で例えるなら、**「ゴミの分別ルール」**や**「郵便物の種別（速達、書留、親展）」**のようなものです。

- **定義**: コミットメッセージに特定のプレフィックス（接頭辞）を付けることで、変更の意図を明確にする仕様。
- **目的**:
    1.  **人間が読みやすくする**: 履歴を見ただけで「機能追加」か「バグ修正」か判断できる。
    2.  **機械が処理できるようにする**: 自動的にバージョン番号を上げたり、変更履歴（Changelog）を生成したりできる。

## 2. ライブラリのアプローチとロジック
この仕様では、コミットメッセージを以下の構造で書くことを定めています。

```text
<型(type)>[適用範囲(scope)]: <タイトル(description)>

[本文(body)]

[フッター(footer)]
```

主要なタイプと、それらが意味する「変更の性質」は以下の通りです。

| タイプ | 意味 (英語) | 説明 | SemVerへの影響 |
| :--- | :--- | :--- | :--- |
| **feat** | Feature | **新機能の追加**。ユーザーに新しい価値を提供した場合に使います。 | **MINOR** (1.0.0 -> 1.1.0) |
| **fix** | Fix | **バグ修正**。ユーザー向けの不具合を直した場合に使います。 | **PATCH** (1.0.0 -> 1.0.1) |
| **docs** | Documentation | **ドキュメントのみ**の変更。コードの動作には影響しません。 | なし |
| **style** | Style | **コードの意味に影響しない変更**。空白、フォーマット、セミコロンの欠落など。CSSの変更ではありません（CSS修正はfeatやfixになることが多い）。 | なし |
| **refactor** | Refactoring | **リファクタリング**。バグ修正も機能追加も行わないコードの内部構造の変更。 | なし |
| **perf** | Performance | **パフォーマンス改善**のためのコード変更。 | なし |
| **test** | Test | テストコードの追加や、既存テストの修正。 | なし |
| **build** | Build | ビルドシステムや外部依存関係の変更（npm, gulp, webpackなど）。 | なし |
| **ci** | CI | CI設定ファイルやスクリプトの変更（GitHub Actions, CircleCIなど）。 | なし |
| **chore** | Chore | **雑用**。ソースコードやテストファイルを変更しない、その他の変更（例：`.gitignore`の変更など）。 | なし |
| **revert** | Revert | 以前のコミットの取り消し。 | なし |

## 3. 実際のコードと文脈（Code Context）
実際の開発現場でよく見るコミットメッセージの例です。

**A. 機能追加 (feat)**
```text
feat: ログイン機能にGoogle認証を追加
```
※ `feat(auth):` のように `()` でスコープ（影響範囲）を指定することもあります。

**B. バグ修正 (fix)**
```text
fix: スマートフォンでヘッダーが崩れる問題を修正
```

**C. ドキュメント (docs)**
```text
docs: READMEにセットアップ手順を追記
```

**D. リファクタリング (refactor)**
```text
refactor: ユーザー取得ロジックをカスタムフックに分離
```

**E. 雑用 (chore)**
```text
chore: 不要なコンソールログを削除
```
※ `chore` は「その他」として便利に使われがちですが、本来は「ビルドプロセスや補助ツールの変更」を指すことが多いです。

## 4. もしこの技術を使わなかったら？（The Hard Way）
もしこのルールがないと、コミットログは以下のようになります。

```text
修正
update
バグ直した
機能追加
wip
aaa
```

- **検索不能**: 「いつログイン機能が入ったか？」を探すのに、全てのコミットの中身を見る必要があります。
- **自動化不能**: どのバージョンをリリースすればいいか、機械的に判断できません。
- **カオス**: チームメンバーがそれぞれ独自の書き方をし始め、履歴が解読不能になります。

## 5. 技術選定とプロ視点の分析
- **メリット**:
    - **可読性**: `git log` を見ただけでプロジェクトの歴史が物語のように分かります。
    - **自動化**: `semantic-release` などのツールを使えば、コミットメッセージから自動的にバージョン番号を決定し、リリースノートを生成できます。
- **注意点**:
    - **慣れが必要**: 最初は「これは `chore` か `style` か？」と迷うことがあります。
    - **厳密すぎると疲れる**: 個人開発や学習段階では、`feat`, `fix`, `docs`, `chore`, `refactor` くらいの主要なものだけ使い分ければ十分です。

## 6. さらなる理解のための推奨リソース
- [Conventional Commits 日本語訳](https://www.conventionalcommits.org/ja/v1.0.0/)
    - まずはここを一読してください。非常に短くまとまっています。
